#ifndef _TETRIS_H

#define _TETRIS_H

#include "headers/figure.h"
#include "headers/file_reader.h"
#include "types/cell.h"
#include "types/states.h"
#include <ncurses.h>
#include <pthread.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>

#define WIDTH 10
#define HEIGHT 20

#define UNUSED(x) ((void)(x))

typedef struct {
  figure_t *current_figure;
  figure_t *next_figure;
  UserAction_t state;
  int score;
  int high_score;
  cell_t game_field[HEIGHT][WIDTH];
  int pause;
  int speed;
  int level;
} GameInfo_t;

/**
 * @brief Перемещает текущую фигуру влево или вправо. Если текущее состояние не
 * является LEFT или RIGHT, или игра находится на паузе, функция ничего не
 * делает.
 * @param gi Структура конфигурации игры, содержащая текущее ее состояние (LEFT
 * - влево, RIGHT - вправо)
 */
void move_figure(GameInfo_t *gi);

/**
 * @brief Функция вызывается по факту окончания основного игрового цикла и
 * подчищает все выделенные ресурсы, а также завершает работу ncurses
 * @param gi Структура конфигурации игры
 * @param thread Поток обработки падения фигуры вниз
 */
void recall(GameInfo_t *gi, pthread_t *thread);

/**
 * @brief Сразу опускает текущую фигуру вниз до столкновения с дном или другой
 * фигурой. Цикл `while` работает, пока не произойдет столкновение. Внутри цикла
 * координата `y` текущей фигуры увеличивается на 1, имитируя падение.
 * @param gi Структура конфигурации игры
 */
void quick_fall(GameInfo_t *gi);

/**
 * @brief Эта функция обновляет счет игры после завершения падения фигуры. К
 * счету игры (`gi->score`) добавляется количество очков, соответствующее
 * количеству очищенных линий. Если текущий счет больше максимального счета,
 * максимальный счет обновляется.
 * @param gi Структура конфигурации игры
 */
void gain_score(GameInfo_t *gi);

/**
 * @brief Переключает состояние паузы игры. Если `gi->state` равно PAUSE,
 * значение `gi->pause` инвертируется.
 * @param gi Структура конфигурации игры
 */
void take_pause(GameInfo_t *gi);

/**
 * @brief Завершает падение текущей фигуры, если она столкнулась с дном или
 * другой фигурой Если происходит столкновение (`is_collision_y(gi)`), поток,
 * отвечающий за падение фигуры, завершается с помощью `pthread_cancel(**thread)
 * @param gi Структура конфигурации игры
 * @param thread Поток обработки падения фигуры вниз
 */
void terminate_figure(GameInfo_t *gi, pthread_t **thread);

/**
 * @brief Функция инициализирует библиотеку ncurses для вывода графики в
 * консоли. Вызывается функция `initscr()`, чтобы инициализировать экран
 * ncurses. Включаются различные опции ncurses:
 * - `noecho()`: отключает отображение введенных символов на экране.
 * - `cbreak()`: включает режим "немедленного ввода", т. е. ввод обрабатывается
 * сразу после нажатия клавиши.
 * - `keypad(stdscr, TRUE)`: включает обработку функциональных клавиш.
 * - `curs_set(0)`: скрывает курсор.
 * - `timeout(100)`: устанавливает таймаут для ввода в 100 миллисекунд.
 * - Вызывается функция `start_color()`, чтобы включить поддержку цвета.
 * - Задаются цветовые пары для разных элементов игры.
 */
void init_ncurses();

/**
 * @brief Вращает текущую фигуру против часовой стрелки. Если `gi->state` не
 * равно ROTATE, функция ничего не делает Высота и ширина фигуры меняются
 * местами
 * @param gi Структура конфигурации игры
 */
void rotate_figure(GameInfo_t *gi);

/**
 * @brief Обновляет отображение игрового поля на экране.
 * @param gi Структура конфигурации игры
 */
void render(GameInfo_t *gi);

/**
 * @brief Отменяет вращение фигуры, если после вращения происходит столкновение
 * или фигура выходит за границы игрового поля.
 * @param gi Структура конфигурации игры
 */
void restore_rotate(GameInfo_t *gi);

/**
 * @brief Эта функция реализует падение фигуры вниз. Она выполняется в отдельном
 * потоке Цикл `while` работает, пока не произойдет столкновение фигуры с дном
 * или другой фигурой
 * @param gi Структура конфигурации игры
 */
void *fall_figure(void *gi);

/**
 * @brief Создает новую фигуру и запускает ее падение в отдельном потоке. Если
 * `gi->next_figure` равно NULL, создается новая фигура (`gi->next_figure`).
 * Текущая фигура (`gi->current_figure`) становится равной следующей фигуре
 * (`gi->next_figure`). Создается новая фигура для `gi->next_figure`. Создается
 * новый поток с помощью `pthread_create`, в котором запускается функция
 * `fall_figure`.
 * @param gi Структура конфигурации игры
 * @param thread Поток обработки падения фигуры вниз
 */
void spawn_figure(GameInfo_t *gi, pthread_t **thread);

/**
 * @brief Сдвигает все строки игрового поля, расположенные выше указанной линии,
 * вниз.
 * @param field Массив для сдвига
 * @param line Индекс удаляемой строки
 */
void move_down(cell_t field[][WIDTH], int line);

/**
 * @brief Проверяется, находится ли текущая фигура на самом верху игрового поля
 * и происходит ли столкновение фигуры с дном или другой фигурой. Если оба
 * условия истинны, игра завершена и функция возвращает 1.
 * @param gi Структура конфигурации игры
 * @return 1 если поле не заполнено и фигура может падать
 */
int game_over(GameInfo_t *gi);

/**
 * @brief В функцию на вход подается количество очищенных линий, в зависимости
 * от этого начисляются очки
 * @param lines_cleared Количество удаленных одновременно линий
 * @return Возвращает конечное количество очков за конкретное количество линий
 */
int calculate_score(int lines_cleared);

/**
 * @brief Проверяет, происходит ли столкновение текущей фигуры с дном игрового
 * поля или с другими фигурами при движении вниз.
 * @param gi Структура конфигурации игры
 * @return Возвращает 1, если столкновение произошло, 0 - в обратном случае
 */
int is_collision_y(GameInfo_t *gi);

/**
 * @brief Проверяет, происходит ли столкновение текущей фигуры с левой или
 * правой границей игрового поля или с другими фигурами при движении по
 * горизонтали.
 * @param gi Структура конфигурации игры
 * @param dir Направление движения (1, -1 и 0)
 * @return Возвращает 1, если столкновение произошло, 0 - в обратном случае
 */
int is_collision_x(GameInfo_t *gi, int dir);

/**
 * @brief Эта функция проверяет игровое поле  на наличие полностью заполненных
 * линий и очищает их, сдвигая все вышележащие линии вниз.
 * @param field Игровое поле
 * @return Количество очишеных линий
 */
int clear_lines(cell_t field[][WIDTH]);

/**
 * @brief Отрисовывает горизонтальную границу в верхней части игрового поля.
 */
void render_border();

/**
 * @brief Отрисовывает игровое поле на экране.
 * @param t Массив для отрисовки
 */
void render_game(cell_t t[HEIGHT][WIDTH]);

/**
 * @brief Отображает следующую фигуру на боковой панели.
 * @param gi Структура конфигурации игры
 */
void render_next_figure(GameInfo_t *gi);

/**
 * @brief Отображает боковую панель с информацией о игре.
 * @param gi Структура конфигурации игры
 */
void render_side_panel(GameInfo_t *gi);

/**
 * @brief Отображает сообщение о завершении игры на экране.
 * @param gi Структура конфигурации игры
 */
void terminate_game(GameInfo_t *gi);

/**
 * @brief Копирует данные из одного двумерного массива. Внутри циклов значения
 * `value` и `color_pair` из каждой ячейки массива `ar` копируются в
 * соответствующие ячейки массива `t`.
 * @param ar Что копировать
 * @param t Куда копировать
 */
void copy_array(cell_t ar[][WIDTH], cell_t t[][WIDTH]);

/**
 * @brief Добавляет ячейки текущей фигуры в массив игрового поля.
 * @param gi Структура конфигурации игры
 * @param t То, что прибавлять
 */
void sum_array(GameInfo_t *gi, cell_t t[][WIDTH]);

/**
 * @brief Функция получает текущее действие пользователя (направление движения,
 * вращение, пауза). Используется функция `getch()`, чтобы получить символ,
 * введенный пользователем.
 * @return Возвращает одно из перечисленных в enum состояний, основываясь на
 * вводе пользователя
 */
UserAction_t get_current_state();

#endif //_TETRIS_H